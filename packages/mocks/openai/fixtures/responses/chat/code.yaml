description: Code-related responses for programming queries
category: chat

responses:
  - id: code-python-function
    pattern: "(python|write|create|function)"
    content: |
      Here's a Python function that accomplishes what you're looking for:

      ```python
      def example_function(param1, param2):
          """
          This function demonstrates the concept you asked about.
          
          Args:
              param1: First parameter description
              param2: Second parameter description
          
          Returns:
              The processed result
          """
          result = param1 + param2
          return result

      # Example usage
      output = example_function(10, 20)
      print(f"Result: {output}")
      ```

      This implementation handles the basic case. You can extend it based on your specific requirements.
    role: assistant
    finish_reason: stop
    weight: 1.5

  - id: code-javascript-async
    pattern: "(javascript|async|promise|fetch)"
    content: |
      Here's an example using async/await in JavaScript:

      ```javascript
      async function fetchData(url) {
          try {
              const response = await fetch(url);
              
              if (!response.ok) {
                  throw new Error(`HTTP error! status: ${response.status}`);
              }
              
              const data = await response.json();
              return data;
          } catch (error) {
              console.error('Error fetching data:', error);
              throw error;
          }
      }

      // Usage
      fetchData('https://api.example.com/data')
          .then(data => console.log(data))
          .catch(error => console.error(error));
      ```

      This handles errors properly and follows modern JavaScript best practices.
    role: assistant
    finish_reason: stop
    weight: 1.5

  - id: code-react-component
    pattern: "(react|component|jsx|hook)"
    content: |
      Here's a React component example:

      ```jsx
      import React, { useState, useEffect } from 'react';

      function ExampleComponent({ initialValue }) {
          const [count, setCount] = useState(initialValue || 0);
          const [data, setData] = useState(null);

          useEffect(() => {
              // Fetch data on mount
              fetchSomeData();
          }, []);

          const handleClick = () => {
              setCount(prevCount => prevCount + 1);
          };

          const fetchSomeData = async () => {
              // Simulated API call
              const result = await fetch('/api/data');
              setData(await result.json());
          };

          return (
              <div className="example-component">
                  <h2>Count: {count}</h2>
                  <button onClick={handleClick}>
                      Increment
                  </button>
                  {data && <div>Data: {JSON.stringify(data)}</div>}
              </div>
          );
      }

      export default ExampleComponent;
      ```

      This follows React best practices with hooks and proper state management.
    role: assistant
    finish_reason: stop
    weight: 1.3

  - id: code-sql-query
    pattern: "(sql|query|database|select)"
    content: |
      Here's an SQL query example:

      ```sql
      -- Get aggregated data with joins
      SELECT 
          u.id,
          u.username,
          COUNT(o.id) as order_count,
          SUM(o.total_amount) as total_spent,
          AVG(o.total_amount) as avg_order_value
      FROM users u
      LEFT JOIN orders o ON u.id = o.user_id
      WHERE u.created_at >= DATE_SUB(NOW(), INTERVAL 1 YEAR)
          AND o.status = 'completed'
      GROUP BY u.id, u.username
      HAVING COUNT(o.id) > 5
      ORDER BY total_spent DESC
      LIMIT 100;
      ```

      This query efficiently retrieves and aggregates the data you need.
    role: assistant
    finish_reason: stop
    weight: 1.0

  - id: code-algorithm-explanation
    pattern: "(algorithm|complexity|implement|optimize)"
    content: |
      Here's an efficient implementation of the algorithm:

      ```python
      def optimized_solution(data):
          """
          Time Complexity: O(n log n)
          Space Complexity: O(n)
          """
          # Step 1: Preprocess data
          processed = sorted(data)
          
          # Step 2: Use efficient data structure
          lookup = {}
          result = []
          
          # Step 3: Iterate once
          for item in processed:
              if item not in lookup:
                  lookup[item] = len(result)
                  result.append(item)
          
          return result

      # Example usage
      input_data = [3, 1, 4, 1, 5, 9, 2, 6, 5]
      output = optimized_solution(input_data)
      print(f"Result: {output}")
      ```

      This approach optimizes both time and space complexity while maintaining readability.
    role: assistant
    finish_reason: stop
    weight: 1.2

  - id: code-api-design
    pattern: "(api|endpoint|rest|graphql)"
    content: |
      Here's an API endpoint design example:

      ```python
      from flask import Flask, jsonify, request
      from functools import wraps

      app = Flask(__name__)

      def require_auth(f):
          @wraps(f)
          def decorated_function(*args, **kwargs):
              auth_header = request.headers.get('Authorization')
              if not auth_header or not auth_header.startswith('Bearer '):
                  return jsonify({'error': 'Unauthorized'}), 401
              return f(*args, **kwargs)
          return decorated_function

      @app.route('/api/v1/users/<int:user_id>', methods=['GET'])
      @require_auth
      def get_user(user_id):
          """
          Get user by ID
          
          Returns:
              200: User object
              404: User not found
              401: Unauthorized
          """
          try:
              user = database.get_user(user_id)
              if not user:
                  return jsonify({'error': 'User not found'}), 404
              
              return jsonify({
                  'id': user.id,
                  'username': user.username,
                  'email': user.email,
                  'created_at': user.created_at.isoformat()
              }), 200
          except Exception as e:
              return jsonify({'error': str(e)}), 500

      if __name__ == '__main__':
          app.run(debug=False)
      ```

      This follows RESTful API best practices with proper error handling.
    role: assistant
    finish_reason: stop
    weight: 1.0

  - id: code-testing-example
    pattern: "(test|unittest|pytest|jest)"
    content: |
      Here's a comprehensive testing example:

      ```python
      import pytest
      from unittest.mock import Mock, patch

      class TestExampleFunction:
          """Test suite for example_function"""
          
          def test_basic_functionality(self):
              """Test basic case with valid inputs"""
              result = example_function(10, 20)
              assert result == 30
          
          def test_edge_case_zero(self):
              """Test edge case with zero"""
              result = example_function(0, 0)
              assert result == 0
          
          def test_negative_numbers(self):
              """Test with negative numbers"""
              result = example_function(-5, 10)
              assert result == 5
          
          @patch('module.external_api')
          def test_with_mock(self, mock_api):
              """Test with mocked external dependency"""
              mock_api.return_value = {'data': 'test'}
              
              result = function_using_api()
              
              mock_api.assert_called_once()
              assert result['data'] == 'test'
          
          def test_exception_handling(self):
              """Test proper exception handling"""
              with pytest.raises(ValueError):
                  example_function(None, 10)

      if __name__ == '__main__':
          pytest.main([__file__, '-v'])
      ```

      This covers the main test cases including edge cases and mocking.
    role: assistant
    finish_reason: stop
    weight: 1.0

  - id: code-debugging-tips
    pattern: "(debug|error|fix|bug)"
    content: |
      Here are some debugging strategies for your code:

      ```python
      import logging
      from pdb import set_trace

      # Configure logging
      logging.basicConfig(
          level=logging.DEBUG,
          format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
      )
      logger = logging.getLogger(__name__)

      def debug_function(data):
          logger.debug(f"Function called with: {data}")
          
          try:
              # Add strategic logging
              logger.info("Processing data...")
              result = process_data(data)
              logger.debug(f"Intermediate result: {result}")
              
              # Use debugger when needed
              # set_trace()  # Uncomment to pause execution here
              
              final = transform_result(result)
              logger.info(f"Final result: {final}")
              
              return final
              
          except Exception as e:
              logger.error(f"Error occurred: {e}", exc_info=True)
              raise

      # Common debugging techniques:
      # 1. Add print statements at key points
      # 2. Use logging for production code
      # 3. Use debugger (pdb) for complex issues
      # 4. Check variable types and values
      # 5. Test edge cases separately
      ```

      These techniques will help you identify and fix the issue systematically.
    role: assistant
    finish_reason: stop
    weight: 1.1