// packages/engine/src/interception/dns_interceptor.rs
//! DNS interceptor for redirecting domains to localhost mocks
//!
//! Provides custom DNS resolution to redirect all external domains
//! (api.openai.com, api.stripe.com, etc.) to localhost mock services.

use crate::utils::errors::{EngineError, Result};
use std::collections::HashMap;
use std::net::IpAddr;
use std::sync::Arc;
use tokio::sync::RwLock;
use tracing::{debug, info};

/// DNS mapping from domain to IP address
#[derive(Debug, Clone)]
pub struct DnsMapping {
    /// Domain name (e.g., "api.openai.com")
    pub domain: String,
    
    /// Target IP address (usually 127.0.0.1)
    pub ip_addr: IpAddr,
    
    /// Port (if specified)
    pub port: Option<u16>,
}

impl DnsMapping {
    pub fn new(domain: impl Into<String>, ip_addr: IpAddr) -> Self {
        Self {
            domain: domain.into(),
            ip_addr,
            port: None,
        }
    }
    
    pub fn with_port(mut self, port: u16) -> Self {
        self.port = Some(port);
        self
    }
}

/// DNS interceptor
pub struct DnsInterceptor {
    /// Domain to IP mappings
    mappings: Arc<RwLock<HashMap<String, DnsMapping>>>,
    
    /// Default IP for unmapped domains
    default_ip: IpAddr,
}

impl DnsInterceptor {
    /// Create a new DNS interceptor
    pub fn new() -> Self {
        Self {
            mappings: Arc::new(RwLock::new(HashMap::new())),
            default_ip: "127.0.0.1".parse().unwrap(),
        }
    }
    
    /// Create DNS interceptor with default localhost mappings
    pub fn with_defaults() -> Self {
        let interceptor = Self::new();
        
        // Add common API domains
        let domains = vec![
            "api.openai.com",
            "api.anthropic.com",
            "api.stripe.com",
            "api.cohere.ai",
            "generativelanguage.googleapis.com",
        ];
        
        for domain in domains {
            let _ = futures::executor::block_on(interceptor.add_mapping(DnsMapping::new(
                domain,
                "127.0.0.1".parse().unwrap(),
            )));
        }
        
        interceptor
    }
    
    /// Add a DNS mapping
    pub async fn add_mapping(&self, mapping: DnsMapping) -> Result<()> {
        let domain = mapping.domain.clone();
        let mut mappings = self.mappings.write().await;
        
        info!(
            "Adding DNS mapping: {} -> {}",
            domain, mapping.ip_addr
        );
        
        mappings.insert(domain, mapping);
        Ok(())
    }
    
    /// Remove a DNS mapping
    pub async fn remove_mapping(&self, domain: &str) -> Result<()> {
        let mut mappings = self.mappings.write().await;
        
        if mappings.remove(domain).is_some() {
            info!("Removed DNS mapping for {}", domain);
            Ok(())
        } else {
            Err(EngineError::ConfigError(format!(
                "No mapping found for domain: {}",
                domain
            )))
        }
    }
    
    /// Resolve a domain name
    pub async fn resolve(&self, domain: &str) -> IpAddr {
        let mappings = self.mappings.read().await;
        
        if let Some(mapping) = mappings.get(domain) {
            debug!("Resolved {} -> {}", domain, mapping.ip_addr);
            mapping.ip_addr
        } else {
            debug!(
                "No mapping for {}, using default {}",
                domain, self.default_ip
            );
            self.default_ip
        }
    }
    
    /// Get all mappings
    pub async fn get_mappings(&self) -> Vec<DnsMapping> {
        let mappings = self.mappings.read().await;
        mappings.values().cloned().collect()
    }
    
    /// Clear all mappings
    pub async fn clear_mappings(&self) {
        let mut mappings = self.mappings.write().await;
        mappings.clear();
        info!("Cleared all DNS mappings");
    }
    
    /// Export mappings as /etc/hosts format
    pub async fn export_hosts_file(&self) -> String {
        let mappings = self.mappings.read().await;
        
        let mut output = String::from("# Sentra Lab DNS Mappings\n");
        output.push_str("# Generated by DNS Interceptor\n\n");
        
        for mapping in mappings.values() {
            output.push_str(&format!("{}\t{}\n", mapping.ip_addr, mapping.domain));
        }
        
        output
    }
}

impl Default for DnsInterceptor {
    fn default() -> Self {
        Self::new()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[tokio::test]
    async fn test_add_mapping() {
        let interceptor = DnsInterceptor::new();
        
        let mapping = DnsMapping::new("api.example.com", "127.0.0.1".parse().unwrap());
        
        interceptor.add_mapping(mapping).await.unwrap();
        
        let resolved = interceptor.resolve("api.example.com").await;
        assert_eq!(resolved.to_string(), "127.0.0.1");
    }
    
    #[tokio::test]
    async fn test_default_mappings() {
        let interceptor = DnsInterceptor::with_defaults();
        
        let resolved = interceptor.resolve("api.openai.com").await;
        assert_eq!(resolved.to_string(), "127.0.0.1");
        
        let resolved = interceptor.resolve("api.stripe.com").await;
        assert_eq!(resolved.to_string(), "127.0.0.1");
    }
    
    #[tokio::test]
    async fn test_unknown_domain() {
        let interceptor = DnsInterceptor::new();
        
        let resolved = interceptor.resolve("unknown.example.com").await;
        assert_eq!(resolved.to_string(), "127.0.0.1"); // Default
    }
    
    #[tokio::test]
    async fn test_remove_mapping() {
        let interceptor = DnsInterceptor::new();
        
        let mapping = DnsMapping::new("api.example.com", "127.0.0.1".parse().unwrap());
        interceptor.add_mapping(mapping).await.unwrap();
        
        interceptor.remove_mapping("api.example.com").await.unwrap();
        
        let mappings = interceptor.get_mappings().await;
        assert_eq!(mappings.len(), 0);
    }
    
    #[tokio::test]
    async fn test_export_hosts_file() {
        let interceptor = DnsInterceptor::new();
        
        let mapping = DnsMapping::new("api.example.com", "127.0.0.1".parse().unwrap());
        interceptor.add_mapping(mapping).await.unwrap();
        
        let hosts = interceptor.export_hosts_file().await;
        assert!(hosts.contains("127.0.0.1"));
        assert!(hosts.contains("api.example.com"));
    }
}